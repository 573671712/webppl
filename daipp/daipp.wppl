/*
WebPPL functions to manage the context and prediction networks.

These should be used to annotate the target program as so:
  Insert an initContext at start of thunk to initialize.
  Insert updateContext after each sample statement.
  Optional to do updateContext at other places (after primitives, fn returns).
  At sample statements guide as so: `sample(origERP, origParams, {guide: DAIPPguide(ERPtype, origParams)})`.
It should be possible for the daipp package to provide macros that do most of this....

Two key helper functions are in a corresponding DAIPP.js file:
daipp.val2vec embeds js objects into vectors,
daipp.vec2dist chooses an importance ERP ad generates its params.
*/


//A function used to initialize the context, given some data (or a summary of data)
// dritchie: It's not clear to me why we really need another net here? Why not let the initial
//    context be the output of val2vec?
var initNet = nn.mlp(daipp.latentSize, [
  {nOut: daipp.latentSize, activation: nn.tanh},
  {nOut: daipp.latentSize}
], 'initNet');
initNet.setTraining(true)
var initContext = function(data) {
  var dataVec = daipp.val2vec(data)

  var context = daipp.nneval(initNet, dataVec);

  globalStore.context = context

  return
}

//A function used to update the context upon getting a sampled (or deterministic) value
//TODO: make deeper? use GRU / LSTM? ResNet?
//TODO: take optional name/type to allow different update nets, eg for sample vs deterministic vs return.
var updateNet = nn.mlp(3*daipp.latentSize, [
  {nOut: daipp.latentSize, activation: nn.tanh},
  {nOut: daipp.latentSize}
], 'updateNet');
updateNet.setTraining(true)
var updateContext = function(val) {
  var dataVec = daipp.val2vec(val)
  var address = getRelativeAddress()
  var addressVec = daipp.val2vec(address)
  var context = globalStore.context

  var newContext = daipp.nneval(updateNet, ad.tensor.concat(context, addressVec, dataVec));

  globalStore.context = newContext

  return
}

//A function to predict the params of the importance distribution at a sample statement.
//Takes the sigature of the domain of the original ERP.
// dritchie: Am I correct that 'val' here is the original params for the ERP? If so,
//    we probably want to manually lift this array to Tensor, right?
var predictNet = nn.mlp(3*daipp.latentSize, [
  {nOut: daipp.latentSize, activation: nn.tanh},
  {nOut: daipp.latentSize}
], 'predictNet');
predictNet.setTraining(true)
var DAIPPguide = function(ERP, val) {
  var dataVec = daipp.val2vec(val)
  var address = getRelativeAddress()
  //TODO: at the moment the address will be a single string, so val2vec will learn a separate embedding per address. we may want to split the string into an array (of syntax sites); in that case val2vec will use an RNN along the array, making related addresses have related vectors.
  var addressVec = daipp.val2vec(address)
  var context = globalStore.context

  //merge the val, context, address together
  var predict = daipp.nneval(predictNet, ad.tensor.concat(context, addressVec, datavec));

  //generate params as appropriate to ERP
  return daipp.vec2dist(predict, ERP)
}
