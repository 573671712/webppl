var X = map(Vector, readJSON('iris_inputs.json'));

var zero2 = Vector([0, 0]);
var I2 = Matrix([[1, 0], [0, 1]]);

var zDim = 2;
var hDecodeDim = 4;
var hEncodeDim = 4;
var xDim = 4; // 4 for iris data set

var observe = function(erp, params, val) {
  factor(erp.score(params, val));
};

var forEach = function(arr, fn) {
  if (arr.length > 0) {
    fn(first(arr));
    forEach(rest(arr), fn);
  }
};

var model = function() {

  // TODO: We're unnecessarily creating these deltaERP + Tensor on
  // every execution. They're inside the model so they can be
  // registered with the coroutine. So maybe have paramChoice take a
  // function which it calls only on the first run?

  // Initialized parameter _171_133 to Tensor([4,4])
  // Initialized parameter _171_136 to Tensor([2,4])
  // Initialized parameter _171_139 to Tensor([2,4])
  // Initialized parameter _171_142 to Tensor([4,1])
  // Initialized parameter _171_145 to Tensor([2,1])
  // Initialized parameter _171_148 to Tensor([2,1])
  // Initialized parameter _171_151 to Tensor([4,2])
  // Initialized parameter _171_154 to Tensor([4,4])
  // Initialized parameter _171_157 to Tensor([4,4])
  // Initialized parameter _171_160 to Tensor([4,1])
  // Initialized parameter _171_163 to Tensor([4,1])
  // Initialized parameter _171_166 to Tensor([4,1])

  // Variational parameters.
  var W0 = paramChoice(deltaERP(zeros([hEncodeDim, xDim]).fillRandom()));
  var W1 = paramChoice(deltaERP(zeros([zDim, hEncodeDim]).fillRandom()));
  var W2 = paramChoice(deltaERP(zeros([zDim, hEncodeDim]).fillRandom()));

  var b0 = paramChoice(deltaERP(zeros([hEncodeDim, 1]).fillRandom()));
  var b1 = paramChoice(deltaERP(zeros([zDim, 1]).fillRandom()));
  var b2 = paramChoice(deltaERP(zeros([zDim, 1]).fillRandom()));

  // Model parameters.
  var W3 = paramChoice(deltaERP(zeros([hDecodeDim, zDim]).fillRandom()));
  var W4 = paramChoice(deltaERP(zeros([xDim, hDecodeDim]).fillRandom()));
  var W5 = paramChoice(deltaERP(zeros([xDim, hDecodeDim]).fillRandom()));

  var b3 = paramChoice(deltaERP(zeros([hDecodeDim, 1]).fillRandom()));
  var b4 = paramChoice(deltaERP(zeros([xDim, 1]).fillRandom()));
  var b5 = paramChoice(deltaERP(zeros([xDim, 1]).fillRandom()));


  forEach(X, function(x) {

    // Encoder.
    var hEncode = ad.tensor.tanh(ad.tensor.add(ad.tensor.dot(W0, x), b0));
    var zMu = ad.tensor.add(ad.tensor.dot(W1, hEncode), b1);
    var zSigma2 = ad.tensor.exp(ad.tensor.add(ad.tensor.dot(W2, hEncode), b2));
    var guide = sampleGuide(multivariateGaussianERP, [zMu, ad.tensor.diag(zSigma2)], { reparam: true });

    // Prior.
    var z = sample(multivariateGaussianERP, [zero2, I2], { guideVal: guide });

    // Decoder.
    var hDecode = ad.tensor.tanh(ad.tensor.add(ad.tensor.dot(W3, z), b3));
    var xMu = ad.tensor.add(ad.tensor.dot(W4, hDecode), b4);
    var xSigma2 = ad.tensor.exp(ad.tensor.add(ad.tensor.dot(W5, hDecode), b5));

    observe(multivariateGaussianERP, [xMu, ad.tensor.diag(xSigma2)], x);
  });

  return 0;

};

//repeat(10, model);


var encode = function(x, W0, W1, b0, b1) {
  var hEncode = ad.tensor.tanh(ad.tensor.add(ad.tensor.dot(W0, x), b0));
  var zMu = ad.tensor.add(ad.tensor.dot(W1, hEncode), b1);
  return zMu;
};

var erp = Variational(model, { steps: 1000, stepSize: 0.001, samplesPerStep: 5, returnSamples: 1 });

writeJSON('params.json', map(function(x) {
  var W0 = erp.parameters._171_133;
  var W1 = erp.parameters._171_136;
  var b0 = erp.parameters._171_142;
  var b1 = erp.parameters._171_145;
  return encode(x, W0, W1, b0, b1).toFlatArray();
}, X));

'done';
