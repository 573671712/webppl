var X = readJSONDataSet('mnist_inputs.json');

var initSigma = 0.1;
var reg = 0.001; // Model params regularization. No idea of sensible magnitude.
var zDim = 2;
var hDecodeDim = 500;
var hEncodeDim = 500;
var xDim = 784;

var encode = function(x, W, b, returnMean) {
  var W0 = W[0], W1 = W[1], W2 = W[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  var h = ad.tensor.tanh(ad.tensor.add(ad.tensor.dot(W0, x), b0));
  var mu = ad.tensor.add(ad.tensor.dot(W1, h), b1);
  var sigma2 = ad.tensor.exp(ad.tensor.add(ad.tensor.dot(W2, h), b2));
  if (returnMean) {
    return mu;
  } else {
    return sampleGuide(diagCovGaussianERP, [mu, sigma2]);
  }
};

var decode = function(z, W, b) {
  var W3 = W[0], W4 = W[1];
  var b3 = b[0], b4 = b[1];
  var h = ad.tensor.tanh(ad.tensor.add(ad.tensor.dot(W3, z), b3));
  return ad.tensor.sigmoid(ad.tensor.add(ad.tensor.dot(W4, h), b4));
};

var model = function() {
  // Variational parameters.
  var W0 = paramChoice(matrixGaussianERP, [0, initSigma, [hEncodeDim, xDim]], { name: 'W0' });
  var W1 = paramChoice(matrixGaussianERP, [0, initSigma, [zDim, hEncodeDim]], { name: 'W1' });
  var W2 = paramChoice(matrixGaussianERP, [0, initSigma, [zDim, hEncodeDim]], { name: 'W2' });

  var b0 = paramChoice(matrixGaussianERP, [0, initSigma, [hEncodeDim, 1]], { name: 'b0' });
  var b1 = paramChoice(matrixGaussianERP, [0, initSigma, [zDim, 1]], { name: 'b1' });
  var b2 = paramChoice(matrixGaussianERP, [0, initSigma, [zDim, 1]], { name: 'b2' });

  // Model parameters.
  var _W3 = paramChoice(matrixGaussianERP, [0, initSigma, [hDecodeDim, zDim]], { name: 'W3' });
  var _W4 = paramChoice(matrixGaussianERP, [0, initSigma, [xDim, hDecodeDim]], { name: 'W4' });

  var _b3 = paramChoice(matrixGaussianERP, [0, initSigma, [hDecodeDim, 1]], { name: 'b3' });
  var _b4 = paramChoice(matrixGaussianERP, [0, initSigma, [xDim, 1]], { name: 'b4' });

  var W3g = sampleGuide(deltaERP, [_W3]);
  var W4g = sampleGuide(deltaERP, [_W4]);
  var b3g = sampleGuide(deltaERP, [_b3]);
  var b4g = sampleGuide(deltaERP, [_b4]);

  var W3 = sample(matrixGaussianERP, [0, 1, [hDecodeDim, zDim]], { guideVal: W3g });
  var W4 = sample(matrixGaussianERP, [0, 1, [xDim, hDecodeDim]], { guideVal: W4g });
  var b3 = sample(matrixGaussianERP, [0, 1, [hDecodeDim, 1]], { guideVal: b3g });
  var b4 = sample(matrixGaussianERP, [0, 1, [xDim, 1]], { guideVal: b4g });

  forEach(X, function(x) {
    var guide = encode(x, [W0, W1, W2], [b0, b1, b2]);
    var z = sample(diagCovGaussianERP, [Vector([0, 0]), Vector([1, 1])], { guideVal: guide });
    var p = decode(z, [W3, W4], [b3, b4]);
    factor(mvBernoulliERP.score([p], x));
  });

  return 0;
};

var dumpSamples = function(i, params) {
  var fn = 'vae/samples/' + i + '.json';
  writeJSON(fn, repeat(20, function() {
    var z = sample(diagCovGaussianERP, [Vector([0, 0]), Vector([1, 1])]);
    var p = decode(z, [params.W3, params.W4], [params.b3, params.b4]);
    return p.toFlatArray();
  }));
};

var dumpLatents = function(i, params) {
  var fn = 'vae/latents/' + i + '.json';
  writeJSON(fn, map(function(x) {
    var W = [params.W0, params.W1, params.W2];
    var b = [params.b0, params.b1, params.b2];
    return encode(x, W, b, true).toFlatArray();
  }, X.slice(0, 1000)));
};

var dumpParams = function(i, params) {
  var fn = 'vae/params/' + i + '.json';
  var out = mapObject(function(name, param) {
    return param.toFlatArray();
  }, params);
  writeJSON(fn, out);
};

var erp = Variational(model, {
  optimizer: 'adam',
  steps: 10000,
  stepSize: 0.001,
  samplesPerStep: 1,
  returnSamples: 1,
  miniBatchSize: 100,
  callback: function(i, params) {
    dumpLatents(i, params);
    if (i % 100 === 0) {
      dumpSamples(i, params);
      dumpParams(i, params);
    }
  }
});

'done';
